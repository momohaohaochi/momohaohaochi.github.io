---
title: 二进制和简单排序
date: '2021-03-12 20:54:00'
tags:
- MSB
- Algorithm
- Binary
- Java
---
# 二进制和简单排序

## 原码，反码，补码

计算机中对整型数字的存储和计算都是使用其二进制补码的形式。以 int 为例，共使用 32 位进行存储，其中最高位是符号位（1 代表负数，0 代表非负数）。

### 原码

**原码就是符号位加真值**

| 十进制 | 二进制原码（int）                           |
| ------ | ----------------------------------------- |
| 5      | `0000 0000 0000 0000 0000 0000 0000 0101` |
| 0      | `0000 0000 0000 0000 0000 0000 0000 0000` |
| -5     | `1000 0000 0000 0000 0000 0000 0000 0101` |

### 反码

**非负数的反码与原码相同；负数的反码是其原码符号位不变，其余位取反**

| 十进制 | 二进制反码（int）                           |
| ------ | ----------------------------------------- |
| 5      | `0000 0000 0000 0000 0000 0000 0000 0101` |
| 0      | `0000 0000 0000 0000 0000 0000 0000 0000` |
| -5     | `1111 1111 1111 1111 1111 1111 1111 1010` |

### 补码

**非负数的补码与原码相同；负数的补码是其反码加一**

| 十进制 | 二进制补码（int）                           |
| ------ | ----------------------------------------- |
| 5      | `0000 0000 0000 0000 0000 0000 0000 0101` |
| 0      | `0000 0000 0000 0000 0000 0000 0000 0000` |
| -5     | `1111 1111 1111 1111 1111 1111 1111 1011` |

### 总结

**非负数的反码，补码与原码相同；负数的反码是原码符号位不变，其余位取反；负数的补码是其反码加一。**

### 思考

1. 为什么负数的补码要用反码加一

   因为计算机只能处理二进制位，所以对算数运算（`+`、`-`、`*`、`/`）都是使用位运算（`&`、`|`、`^`、`~`）进行组合实现的。为了保证无论是正数和正数，正数和负数，负数和负数间进行某一算数运算时都使用同一套逻辑，所以将负数的补码设计为了其反码加一。（如果有多套逻辑，就会造成每次做算数运算的时候都需要进行判断，从而使得效率降低）

2. int 型整数的取值范围计算

   int 使用 32 位对其值进行存储，其中最高位是符号位，所以有 31 位表示其真实的数值。所以 int 的最大值就是$2^{31}-1$，其中 `-1` 表示的是数字 `0`。而 int 的最小值就是。$-2^{31}$ 所以 int 的取值范围是 $-2^{31}$ ~ $2^{31}-1$

## 位运算

### 取反（`~`）

0 变成 1，1 变成 0

| 原码                  | 取反                  |
| --------------------- | --------------------- |
| `0000 0000 0000 0000` | `1111 1111 1111 1111` |
| `0011 0101 1010 1010` | `1100 1010 0101 0101` |
| `1100 0011 1010 0101` | `0011 1100 0101 1010` |

### 与（`&`）

全是 1 才是 1，否则就是 0

```binary
  0010 1001 1100 0011
& 1011 0111 0111 0101
= 0010 0001 0100 0001
```

### 或（`|`）

有 1 就是 1，否则就是 0

```binary
  0010 1001 1100 0011
| 1011 0111 0111 0101
= 1011 1111 1111 0111
```

### 异或（`^`）

不相同为 1，相同为 0

```binary
  0010 1001 1100 0011
^ 1011 0111 0111 0101
= 1001 1110 1011 0110
```

### 左移（`<<`）

整体向左移动，低位补 0

```binary
     0000 0000 0000 0101    5
<<1  0000 0000 0000 1010    10 = 5*2^1
<<2  0000 0000 0001 0100    20 = 5*2^2
<<34 0000 0000 0001 0100    20 = 5*2^(34%16)

     1111 1111 1111 1011    -5
<<1  1111 1111 1111 0110    -10 = 5*2^1
<<2  1111 1111 1110 1100    -20 = 5*2^2
<<34 1111 1111 1110 1100    -20 = 5*2^(34%16)
```

1. 任意一个整数 N 左移 K 位，结果是 $N*2^K$，即 $N<<K=N*2K$
2. 在 Java 中，当左移的位数 K 超出该类型的最大位数后，会对 K 进行取模。例如对 short 类型的数左移 34 位，实际上移动的位数是 2 位（34%16=2）

### 右移（`>>`）

整体向右移动，高位补符号位

```binary
     0000 0000 0000 0101    5
>>1  0000 0000 0000 0010    2 = 5/2^1
>>2  0000 0000 0000 0001    1 = 5/2^2
>>4  0000 0000 0000 0000    0 = 5/2^4
>>34 0000 0000 0000 0000    0 = 5/2^(34%16)

     1111 1111 1111 1011    -5
>>1  1111 1111 1111 1101    -3
>>2  1111 1111 1111 1110    -2
>>34 1111 1111 1111 1110    -2 = -5>>(34%16)
```

1. 非负整数 N 右移 K 位，结果是 $N/2^K$，即 $N>>K=N/2^K(N\ge0)$
2. 在 Java 中，当右移的位数 K 超出该类型的最大位数后，会对 K 进行取模。例如对 short 类型的数右移 34 位，实际上移动的位数是 2 位（34%16=2）

### 无符号右移（`>>>`）

整体向右移动，高位补 0

```binary
      0000 0000 0000 0101    5
>>>1  0000 0000 0000 0010    2 = 5/2^1
>>>2  0000 0000 0000 0001    1 = 5/2^2
>>>4  0000 0000 0000 0000    0 = 5/2^4
>>>34 0000 0000 0000 0000    0 = 5/2^(34%16)

      1111 1111 1111 1011    -5
>>>1  0111 1111 1111 1101    2147483645
>>>2  0011 1111 1111 1110    1073741822
>>>34 0011 1111 1111 1110    1073741822 = -5>>>(34%16)
```

1. 非负整数的无符号右移和右移是相同的，都符合 $N>>K=N/2^K(N\ge0)$
2. 在 Java 中，当无符号右移的位数 K 超过该类型最大位数后，会对 K 进行取模。例如对 short 类型的数右移 34 位，实际上移动的位数是 2 位（34%16=2）

## 练习题

1. 打印一个整数的二进制表现形式

   > 1. 在计算机中，整数 1 的二进制是：`0000 0000 0000 0000 0000 0000 0000 0001`
   > 2. 所以 `N&1` 的结果，只有最低位可能出现两种情况，其余位都是 0。
   > 3. 如果 N 的最低位是 0，则 `N&1` 就是 0；如果 N 的最低位是 1，则 `N&1` 就是 1
   > 4. 同理，如果将 1 左移 1 位，其二进制变为：`0000 0000 0000 0000 0000 0000 0000 0010`
   > 5. 此时 `N&(1<<1)` 的结果就只受 N 的二进制倒数第二位的影响。
   > 6. 如果 N 的二进制的倒数第二位是 0，则 `N&(1<<1)` 就是 0；如果 N 的二进制的倒数第二位是 1，则 `N&(1<<1)` 就是 2
   > 7. 所以，如果 `N&(1<<K)` 等于 0，就说明 N 的二进制的 K 位是 0；如果 `N&(1<<K)` 不等于 0，就说明 N 的二进制的 K 位是 1
   > 8. 所以要想获取一个数的二进制表现形式，我们可以让这个数依次和 `1<<31`、`1<<30`、……、`1<<0` 进行与运算，判断其每一位上是 0 还是 1

   ```java
   private static void printBinary(int num) {
       for (int i = 31; i >= 0; i--) {
           int b = (num & (1 << i)) == 0 ? 0 : 1;
           System.out.print(b);
       }
       System.out.println();
   }
   ```

## 简单排序

1. 选择排序

   **基本思想**

   > 在未排序的数组中找到最小数的下标，将其放在数组的第 1 个元素位置；然后在剩余未排序的数组中找到最小数的下标，依次放在已排序数组的后面

   **实现过程**

   > 1. 第一轮：用 arr[0] 依次与其后面的数进行比较，找到最小数所在位置的下标，然后将二者进行交换
   > 2. 第二轮：用 arr[1] 依次与其后面的数进行比较，找到最小数所在位置的下标，然后将二者进行交换
   > 3. 依次类推……
   > 4. 第 N 轮：用 arr[N-1] 依次与其后面的数进行比较，找到最小数所在位置的下标，然后将二者进行交换

   **边界条件**

   > 传入的数组为 null，或者数组长度小于 2 的时候，不需要对其进行排序

   ```java
   private static void selectSort(int[] arr){
       if(arr == null || arr.length < 2){
           return;
       }
       for(int i = 0; i < arr.length - 1; i++){
           int minNumIndex = i;
           for(int j = i + 1; j < arr.length; j++){
               minNumIndex = arr[minNumIndex] > arr[j] ? j : minNumIndex;
           }
       }
   }
   
   private static void swap(int[] arr, int i, int j){
       int temp = arr[i];
       arr[i] = arr[j];
       arr[j] = temp;
   }
   ```

2. 冒泡排序

   **基本思想**

   > 在未排序的数组中，相邻两数进行比较，较大的数向后移动

   **实现过程**

   > 第一轮：在 [0, N-1] 范围上，依次比较相邻的两个数，较大的数向后移动，最终在下标为 N-1 的位置上即为最大数
   >
   > 第二轮：在 [0, N-2] 范围上，依次比较相邻的两个数，较大的数向后移动，最终从下标 N-2 的位置开始有序
   >
   > 以此类推……
   >
   > 第 N-1 轮：在 [0, 1] 范围上，依次比较相邻的两个数，较大的向后移动，最终整体有序

   **边界条件**

   > 传入的数组为 null，或者数组长度小于 2 的时候，不需要对其进行排序

   ```java
   private static void bubbleSort(int[] arr) {
       if(arr == null || arr.length < 2){
           return;
       }
       for (int end = arr.length - 1; end > 0; end--) {
           for (int i = 0; i < end; i++) {
               if (arr[i] > arr[i + 1]) {
                   swap(arr, i, i + 1);
               }
           }
       }
   }
   
   private static void swap(int[] arr, int i, int j){
       int temp = arr[i];
       arr[i] = arr[j];
       arr[j] = temp;
   }
   ```

3. 插入排序

   **基本思想**

   > 保证第 [0, i] 位置是有序的。类似于抓扑克牌，手中的牌都是有序的，当抓到一张新牌的时候，从后向前依次比较，将其插入在适当的位置

   **实现过程**

   > 第一轮：arr[0] 本身就是有序的，不需要判断
   >
   > 第二轮：用 arr[1] 与 arr[0] 进行比较，如果 arr[1]\<arr[0]，将 arr[1]与 arr[0] 交换，此时在 [0, 1] 上有序
   >
   > 第三轮：用 arr[2] 与 arr[1] 进行比较，如果 arr[2]\<arr[1]，将 arr[2]与 arr[1] 交换；然后用 arr[1] 与 arr[0] 进行比较，如果 arr[1]\<arr[0]，将 arr[1] 与 arr[0] 进行交换，此时在 [0,2] 上有序
   >
   > 以此类推……
   >
   > 第 N 轮：用 arr[N-1] 与 arr[N-2] 进行比较，如果 arr[N-1]\<arr[N-2]，将 arr[N-1] 与 arr[N-2] 交换；然后用 arr[N-2] 与 arr[N-3] 进行比较，如果 arr[N-2]\<arr[N-3]，将 arr[N-2] 与 arr[N-3] 交换；……；此时在 [0, N-1] 上有序

   **边界条件**

   > 传入的数组为 null，或者数组长度小于 2 的时候，不需要对其进行排序

   ```java
   private static void insertSort(int[] arr){
       if(arr == null || arr.length < 2){
           return;
       }
       for(int end = 1; end < arr.length; end++){
           for(int curNumIndex = end; curNumIndex - 1 >= 0 && arr[curNumIndex] < arr[curNumIndex - 1]; curNumIndex--){
               swap(arr, curNumIndex, curNumIndex - 1);
           }
       }
   }
   
   private static void swap(int[] arr, int i, int j){
       int temp = arr[i];
       arr[i] = arr[j];
       arr[j] = temp;
   }
   ```

